import random
from math import gcd
import gmpy2
from typing import Tuple, Optional


class VulnerableRSA:
    def __init__(self, key_size: int = 1024):
        self.key_size = key_size
        self.p = None
        self.q = None
        self.n = None
        self.e = 65537  # Common public exponent
        self.d = None

    def _generate_weak_prime(self, bits: int) -> int:
        """Generates a weak prime number for demonstration purposes"""
        # This intentionally generates weak primes
        start = gmpy2.mpz(2) ** (bits - 1)
        end = gmpy2.mpz(2) ** bits - 1
        while True:
            p = gmpy2.mpz(random.randrange(start, end))
            if gmpy2.is_prime(p):
                return p

    def generate_keys(self) -> Tuple[Tuple[int, int], Tuple[int, int]]:
        """Generates a pair of public and private keys using weak primes"""
        # Generate weak primes
        self.p = self._generate_weak_prime(self.key_size // 2)
        self.q = self._generate_weak_prime(self.key_size // 2)

        self.n = self.p * self.q
        phi = (self.p - 1) * (self.q - 1)

        # Calculate private exponent
        self.d = gmpy2.invert(self.e, phi)

        return ((self.e, self.n), (self.d, self.n))

    def encrypt(self, message: int) -> int:
        """Encrypts a message using the public key"""
        return pow(message, self.e, self.n)

    def decrypt(self, ciphertext: int) -> int:
        """Decrypts a ciphertext using the private key"""
        return pow(ciphertext, self.d, self.n)


class RSAAttacker:
    def __init__(self):
        self.known_bits = None
        self.total_bits = None

    def set_partial_key(self, partial_d: int, known_bits: int, total_bits: int):
        """Sets the partial private key information"""
        self.known_bits = known_bits
        self.total_bits = total_bits
        self.partial_d = partial_d

    def recover_private_key(self, e: int, n: int) -> Optional[int]:
        """Attempts to recover the full private key using partial information"""
        if self.known_bits is None:
            return None

        # We'll use a simplified approach for demonstration
        # In a real attack, more sophisticated methods would be used

        d_upper = self.partial_d << (self.total_bits - self.known_bits)
        d_lower = d_upper | ((1 << (self.total_bits - self.known_bits)) - 1)

        for d in range(d_upper, d_lower + 1):
            # Check if this d is valid
            if (e * d) % gmpy2.next_prime(n) == 1:
                return d

        return None


class SecureRSA:
    def __init__(self, key_size: int = 2048):
        self.key_size = key_size
        self.p = None
        self.q = None
        self.n = None
        self.e = 65537
        self.d = None

    def _generate_strong_prime(self, bits: int) -> int:
        """Generates a strong prime number"""
        return gmpy2.next_prime(
            gmpy2.mpz(2) ** (bits - 1) + gmpy2.mpz(random.getrandbits(bits - 1))
        )

    def generate_keys(self) -> Tuple[Tuple[int, int], Tuple[int, int]]:
        """Generates a pair of public and private keys using strong primes"""
        while True:
            self.p = self._generate_strong_prime(self.key_size // 2)
            self.q = self._generate_strong_prime(self.key_size // 2)

            # Ensure p and q are not too close together
            if abs(self.p - self.q) > 2 ** (self.key_size // 2 - 100):
                break

        self.n = self.p * self.q
        phi = (self.p - 1) * (self.q - 1)

        self.d = gmpy2.invert(self.e, phi)

        return ((self.e, self.n), (self.d, self.n))

    def encrypt(self, message: int) -> int:
        return pow(message, self.e, self.n)

    def decrypt(self, ciphertext: int) -> int:
        return pow(ciphertext, self.d, self.n)


def demonstrate_attack():
    # Create a vulnerable RSA instance
    vuln_rsa = VulnerableRSA(key_size=512)  # Using small key size for demonstration
    pub_key, priv_key = vuln_rsa.generate_keys()
    e, n = pub_key
    d, _ = priv_key

    # Simulate Eve obtaining partial key information
    known_bits = 256  # Half of the private key bits
    partial_d = d >> (512 - known_bits)  # Upper half of private key

    # Eve attempts to recover the full private key
    attacker = RSAAttacker()
    attacker.set_partial_key(partial_d, known_bits, 512)
    recovered_d = attacker.recover_private_key(e, n)

    # Test the attack
    original_message = 12345
    encrypted = vuln_rsa.encrypt(original_message)

    if recovered_d:
        # Test decryption with recovered key
        recovered_message = pow(encrypted, recovered_d, n)
        return original_message == recovered_message
    return False


def demonstrate_secure_implementation():
    # Create a secure RSA instance
    secure_rsa = SecureRSA(key_size=2048)
    pub_key, priv_key = secure_rsa.generate_keys()

    # Test encryption and decryption
    original_message = 12345
    encrypted = secure_rsa.encrypt(original_message)
    decrypted = secure_rsa.decrypt(encrypted)

    return original_message == decrypted


if __name__ == "__main__":
    print("Demonstrating vulnerable RSA implementation...")
    attack_successful = demonstrate_attack()
    print(f"Attack successful: {attack_successful}")

    print("\nDemonstrating secure RSA implementation...")
    secure_implementation_works = demonstrate_secure_implementation()
    print(f"Secure implementation works: {secure_implementation_works}")
